<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Gamemode v.4</title>

    <!-- Working document CSS instead of linking separate .css stylesheet -->
    <style>
	.hidden {
	    display: none;
	}
	.overlay-text {
	    color: white;
	}
    </style>
    <!-- Working document datacopy.js instead of linking separate .js file -->
    <script>
	const instruments = {
  	    "piccolo": {
    		octave: 2,
    		group: ["woodwind", "high"],
    		pitches: [
      		    "F5", "F6", "F7"]},
  	    "flute": {
    		octave: 1,
    		group: ["woodwind", "high"],
    		pitches: [
      		    "F4", "F5", "F6"]},
  	    "oboe": {
    		octave: 1,
    		group: ["woodwind", "high"],
    		pitches: [
      		    "F4", "F5", ]},
  	    "bassoon": {
    		octave: -1,
    		group: ["woodwind", "low"],
    		pitches: [
      		    "F2", "F3", "F4"]},
  	    "clarinet": {
    		octave: 0,
    		group: ["woodwind", "high"],
    		pitches: [
      		    "F3", "F4", "F5", ]},
  	    "bass-clarinet": {
    		octave: -1,
    		group: ["woodwind", "low"],
    		pitches: [
      		    "F2", "F3", "F4"]},
  	    "alto-sax": {
    		octave: 0,
    		group: ["woodwind", "high"],
    		pitches: [
      		    "F3", "F4", "F5", ]},
  	    "tenor-sax": {
    		octave: 0,
    		group: ["woodwind", "low"],
    		pitches: [
      		    "F3", "F4", ]},
  	    "bari-sax": {
    		octave: -1,
    		group: ["woodwind", "low"],
    		pitches: [
      		    "F2", "F3", "F4", ]},
  	    "trumpet": {
    		octave: 0,
    		group: ["brass", "high"],
    		pitches: [
      		    "F3", "F4", "F5", ]},
  	    "french-horn": {
    		octave: 0,
    		group: ["brass", "high"],
    		pitches: [
      		    "F2", "F3", "F4", "F5"]},
  	    "trombone": {
    		octave: -1,
    		group: ["brass", "low"],
    		pitches: [
      		    "F2", "F3", "F4", ]},
  	    "baritone": {
    		octave: -1,
    		group: ["brass", "low"],
    		pitches: [
      		    "F2", "F3", "F4", ]},
  	    "tuba": {
    		octave: -2,
    		group: ["brass", "low"],
    		pitches: [
      		    "F1", "F2", "F3", ]},
	};
    </script>


</head>

<body>
    <h1 class="center">Intonation Trainer</h1>
    
    <div class="ui-container center vert-center">

<!-- ||------------------------Welcome Screen UI--------------------------|| -->
	<br>
	<div id="welcomeScreen" class="vert-center">
	    <button id="gameStart" class="">Start Game</button>
	</div>

<!-- ||------------------------Game Controls UI---------------------------|| -->
	<br>
	<div id="gameControls" class="game-controls hidden">
	    <div class="game-instructions">
		<div id="instructions">Question: Are the notes in tune or out of tune?</div>
	    </div>
	    <div class="waveform-wrapper">
	    	<div id="primaryContainer" class="waveform-container">
		    <div class="overlay-text">
		    	<div id="primaryInstrumentName">Clarinet</div>
		    	<div id="primaryInstrumentNote">F4</div>
		    </div>
	    	</div>
	        <div id="secondaryContainer" class="waveform-container">
		    <div class="overlay-text">
		    	<div id="secondaryInstrumentName">Trumpet</div>
		    	<div id="secondaryInstrumentNote">F4</div>
		    </div>
	    	</div>
	    </div>
	    <div id="2-buttons">
		<button class="game-button " id="in-sharp">In Tune</button>
		<button class="game-button " id="out-flat">Out of Tune</button>
	    </div>
	    <div id="1-button">
		<button id="repeat-button" class="">Replay Audio</button>
	    </div>
	    <div class="text-display">
		<span id="textContent">Feedback</span>
	    </div>
	    <br>
	    <div class="score-area">
		<div>Gamemode: <span id="gamemodeSpan"></span></div>
		<label>Score: </label><span id="score">0</span>
	    </div>
	    <div class="timer-area">
		<span id="timerDisplay" class="">00:00</span>
		<button id="pauseButton" class="">Pause</button>
		<button id="optionsButton">Options</button>
	    </div>
	</div>

<!-- ||-----------------------Menu Screen UI----------------------------|| -->
	<br>
	<div id="menuScreen" class="hidden">
	    <div>
		<span>Difficulty</span>
		<button id="easyButton">Easy</button>
		<button id="mediumButton">Medium</button>
		<button id="hardButton">Hard</button>
	    </div>
	    <div>
		<span>Game Mode</span>
		<button id="freeplayButton">Free Play</button>
		<button id="timermodeButton">Timer</button>
		<button id="challengeButton">Challenge</button>
	    </div>
	    <div>
		<span>Intervals</span>
		<button>Unison</button>
		<button>Octave</button>
		<button>Auto</button>
	    <div>
		<span>Select Instrument:</span>
		<select id="selectInstrumentDropdown">
		    <option value="all">All</option>
		    <option value="brass">Brass Only</option>
		    <option value="woodwind">Woodwinds</option>
		    <option value="high">High Voices</option>
		    <option value="low">Low Voices</option>
		</select>
	    </div>
	    <div>
		<button id="backButton">Back</button>
	    </div>
	</div>

<!-- ||----------------------------Results Screen UI--------------------------|| -->
	<br>
	<div id="resultsScreen" class="hidden")
	    <p>Display results here.</p>
	    <button>Restart</button>
	</div>
    </div>

    <script>

// ||---------------------------------- Menu Screen UI --------------------------------||

// --- Select Instrument ---

	const selectInstrumentDropdown = document.getElementById("selectInstrumentDropdown");
	const instrumentKeys = Object.keys(instruments);
	let activeInstrumentList = instrumentKeys;
	let requireNextRound = false;

	function populateInstrumentDropdown() {
	    for (let i = 0; i < instrumentKeys.length; i++) {
		const newOption = document.createElement("option");
		const newInstrName = instrumentKeys[i];
		newOption.innerHTML = displayName(newInstrName);
		newOption.value = newInstrName;
		selectInstrumentDropdown.appendChild(newOption);
	    }
	}

	document.addEventListener("DOMContentLoaded", populateInstrumentDropdown);
	selectInstrumentDropdown.addEventListener('input', () => {
	    console.log(`${selectInstrumentDropdown.value}`);
	    if (selectInstrumentDropdown.value === "all") {
		activeInstrumentList = instrumentKeys;
	    } else if (selectInstrumentDropdown.value === "brass") {
		activeInstrumentList = Object.entries(instruments)
		    .filter(([name, data]) => data.group.includes("brass"))
		    .map(([name, _]) => name);
	    } else if (selectInstrumentDropdown.value === "woodwind") {
		activeInstrumentList = Object.entries(instruments)
		    .filter(([name, data]) => data.group.includes("woodwind"))
		    .map(([name, _]) => name);
	    } else if (selectInstrumentDropdown.value === "high") {
		activeInstrumentList = Object.entries(instruments)
		    .filter(([name, data]) => data.group.includes("high"))
		    .map(([name, _]) => name);
	    } else if (selectInstrumentDropdown.value === "low") {
		activeInstrumentList = Object.entries(instruments)
		    .filter(([name, data]) => data.group.includes("low"))
		    .map(([name, _]) => name);
	    } else {
	        activeInstrumentList = [selectInstrumentDropdown.value];
	    }
	    console.log(activeInstrumentList);
	    requireNextRound = true;
	});

// --- Select Difficulty ---

	const easyButton = document.getElementById("easyButton");
	const mediumButton = document.getElementById("mediumButton");
	const hardButton = document.getElementById("hardButton");
	let difficulty = 35;
	
	easyButton.addEventListener('click', () => {
	    difficulty = 35;
	    requireNextRound = true;
	});
	mediumButton.addEventListener('click', () => {
	    difficulty = 25;
	    requireNextRound = true;
	});
	hardButton.addEventListener('click', () => {
	    difficulty = 15;
	    requireNextRound = true;
	});

// --- Select Game Mode ---

	let gamemode = "freeplay";

	const freeplayButton = document.getElementById("freeplayButton");
	const timermodeButton = document.getElementById("timermodeButton");
	const challengeButton = document.getElementById("challengeButton");

	freeplayButton.addEventListener('click', () => {
	    if (gamemode !== "freeplay") {
	    	gamemode = "freeplay";
		clearInterval(timerInterval);
		timerInterval = null;
		timer = 0;
		updateTimerDisplay();
		startTimer();
	    	requireNextRound = true;
	    }
	});
	timermodeButton.addEventListener('click', () => {
	    if (gamemode !== "timermode") {
		gamemode = "timermode";
		clearInterval(timerInterval);
		timerInterval = null;
		timer = 180;
		updateTimerDisplay();
		startTimer();
		requireNextRound = true;
	    }
	});
	challengeButton.addEventListener('click', () => {
	    if (gamemode !== "challenge") {
		gamemode = "challenge";
		requireNextRound = true;
	    }
	});
// TODO: implement functionality that allows the user to change the gamemode. Currently, it is designed to run in Free Play mode, where a timer counts up from 0:00 and the score is recorded. The Pause button should maybe read "Finish" to bring the user to the results screen. Results screen can include information like "hardest difficulty reached", "percentage of correct answers", and maybe at some point use cookies to remember "high score" between sessions.

// When the user selects "Timer", it would be nice to have a few different options like a 1 minute, a 3 minute, and a 5 minute option. Now, there needs to be a different function that makes the timer decrease from 1:00 to 0:00, and a function that brings the user to the results screen when time is up, displays the results, and maybe resets the game.

// I'm also thinking about using the START UI screen in this way: using cookies, the last settings are remembered (difficulty, gamemode, intervals, instrument selection) so that pushing "start" will automatically start the game with the last selected settings. Then, on the GAME CONTROLS UI, the "options" button will allow the user to pause and possibly reset their game with different settings. Just pushing "options" and not changing anything will effectively pause the game, allowing the user to push "back" without resetting anything, but changing any of the settings will trigger a "requireRestart" bool and "back" will reset the game with the new settings.

// When the user selects "Challenge", the timer will change to "Lives: 5" and each time a question is answered incorrectly, Lives will decrease. When "lives" gets to 0, just like "timer", the user will be brought to the results screen.

// Maybe to keep the format of <time> <button> <button>, I could use "Reset" in place of "Finish" for the last two game modes. 
	
// ||------------------------------- Global Script Variables ----------------------------------||

	const audioContext = new (window.AudioContext);
	const textContent = document.getElementById("textContent");
	const gameStart = document.getElementById("gameStart");
	const buttonOne = document.getElementById("in-sharp");
	const buttonTwo = document.getElementById("out-flat");
	const repeatButton = document.getElementById("repeat-button");
	const gameControls = document.getElementById("gameControls");
	const scoreText = document.getElementById("score");
	const primaryContainer = document.getElementById("primaryContainer");
	const secondaryContainer = document.getElementById("secondaryContainer");
	const instructions = document.getElementById("instructions");

	let score = 0;
	let round = "inorout";
	let gameStarted = false;
	let primary = null;
	let secondary = null;
	let primaryBuffer = null;
	let secondaryBuffer = null;
	let inTune = true;
	let detuneAmount = 0;
	let sign = 1;
	let roundDuration = 2.5;
	let followUpDuration = 2;
	let panLeft = -.8;
	let panRight = .8;
	let activeSources = [];
	let intervalType = null;
	let playCount = 0;
	let increaseDifficulty = 0;



// ||---------------------------------------Function Definitions-------------------------------||

    // ......Audio Playback Functions......

	async function loadAudioBuffer(filePath) {
  	    const response = await fetch(filePath);
  	    const arrayBuffer = await response.arrayBuffer();
  	    return await audioContext.decodeAudioData(arrayBuffer);
	}

	function playAudioBuffer(audioBuffer, detuneAmount = 0, panValue = 0, duration = roundDuration) {
  	    const source = audioContext.createBufferSource();
  	    source.buffer = audioBuffer;

  	    const gainNode = audioContext.createGain();
  	    const panner = audioContext.createStereoPanner();
  	    panner.pan.value = panValue;

  	    const detuneRatio = Math.pow(2, detuneAmount / 1200);
  	    source.playbackRate.value = detuneRatio;

  	    source.connect(panner).connect(gainNode).connect(audioContext.destination);

  	    const now = audioContext.currentTime;
  	    gainNode.gain.setValueAtTime(1, now);
  	    gainNode.gain.setValueAtTime(1, now + duration);
  	    gainNode.gain.linearRampToValueAtTime(0, now + duration + .5);

  	    source.start(now);
  	    source.stop(now + duration)

  	    activeSources.push(source); // Tracks array of audio sources for stopAllAudio().
	}

	function stopAllAudio() {
	    lightsOff();
  	    activeSources.forEach(source => {
    		try {
      		    source.stop();
    		} catch (e) {
    		}
  	    });
  	    activeSources = [];  // Requires global variable let activeSources = [];
	}

    // ......Randomizing and Round Functions......

    	function randomInstrument() {
	    const name = activeInstrumentList[Math.floor(Math.random() * activeInstrumentList.length)];
	    const instrument = instruments[name];
	    return { instrument, name };
	}

    	function generateRandom() {
     	    // Returns an object to be used as file path for loadAudioBuffer(filePath);
	    const { instrument, name } = randomInstrument();
	    const pitch = instrument.pitches[Math.floor(Math.random() * instrument.pitches.length)];
	    return {
	  	filePath: `tempaudio/${name}/${pitch}.mp3`,
	  	name: name,
	  	pitch: pitch,
	    };
    	}

	function displayName(name) {
      	    return name.replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
	}

	function parseNote(input) {
  	    const note = input.slice(0, -1); // assumes all notes have a 1-digit octave
  	    const octave = parseInt(input.slice(-1), 10);
  	    return { note, octave };
	}

	async function nextRound() {
	    console.log(`difficulty = ${difficulty}, increase = ${increaseDifficulty}`);
	    round = "inorout";
	    instructions.innerHTML = "Question: Are the notes in tune or out of tune?";
	    buttonOne.innerHTML = "In Tune";
	    buttonTwo.innerHTML = "Out of Tune";
	    inTune = Math.random() < 0.5 ? true : false;
	    console.log(`Round = ${round}, inTune = ${inTune}`);
	    if (inTune) {
		detuneAmount = 0;
	    } else {
		sign = Math.random() < 0.5 ? 1 : -1;
		detuneAmount = (sign * difficulty);
	    }
	    primary = generateRandom();
	    // console.log(`Primary: ${primary.name} ${primary.pitch}`)
	    primaryInstrumentName.innerHTML = displayName(primary.name);
	    primaryInstrumentNote.innerHTML = primary.pitch;
	    primaryBuffer = await loadAudioBuffer(primary.filePath);
	    let newNote = null;
	    intervalType = Math.random() < 0.5 ? "octave" : "unison";
	    console.log(`intervalType = ${intervalType}`);
	    if (intervalType === "octave") {
	    // Suggestion: Write all of this as a function: newNote = findOctave();
		secondary = generateRandom();
		let primaryInstrument = instruments[primary.name];
		let secondaryInstrument = instruments[secondary.name];
		const parsedNote = parseNote(primary.pitch);

		if (primaryInstrument.octave === secondaryInstrument.octave) {
		    const direction = Math.random() < .5 ? 1 : -1;
		    const distances = [1, -1, 2, -2, 3, -3, 4, -4, 5, -5, 6, -6];
		    for (let i = 0; i < distances.length; i++) {
			const testOctave = parsedNote.octave + (distances[i] * direction);
			const candidate = parsedNote.note + testOctave;
			if (secondaryInstrument.pitches.includes(candidate)) {
			    newNote = candidate;
			    break;
			}
		    }
		} else {
		    let normalizedOctave = secondaryInstrument.octave - primaryInstrument.octave;
		    let testOctave = parsedNote.octave + normalizedOctave;
		    let candidate = parsedNote.note + testOctave;
		    if (secondaryInstrument.pitches.includes(candidate)) {
			newNote = candidate;
		    } else {
          	    	const direction = Math.random() < .5 ? 1 : -1;
          	    	const distances = [1, -1, 2, -2, 3, -3, 4, -4];
          	    	for (let i = 0; i < distances.length; i++) {
	    		    testOctave = parsedNote.octave + (distances[i] * direction);
	    		    candidate = parsedNote.note + testOctave;
	    		    if (secondaryInstrument.pitches.includes(candidate)) {
	      		    	newNote = candidate;
	      		    	break;
          	    	    }
			}
		    }
		}
	    } else {
	    // Suggestion: Write all of this as a function: newNote = findUnison();
		secondary = generateRandom();
		newNote = primary.pitch;
		let pitches = [];
		let name = "";
		let instrument = null;
		while (!pitches.includes(primary.pitch)) {
		    name = activeInstrumentList[Math.floor(Math.random() * activeInstrumentList.length)];
		    instrument = instruments[name];
		    pitches = instrument.pitches;
		    secondary.name = name;
		}
	    }
	    secondaryInstrumentName.innerHTML = displayName(secondary.name);
	    secondaryInstrumentNote.innerHTML = newNote;	    
	    const filePath = `tempaudio/${secondary.name}/${newNote}.mp3`;
	    secondaryBuffer = await loadAudioBuffer(filePath);

	    playAudioBuffer(primaryBuffer);
	    // console.log(`${primary.filePath}`);
	    playAudioBuffer(secondaryBuffer, detuneAmount);
	    // console.log(`Secondary: ${secondary.name} ${newNote} ${detuneAmount}`);
	    playCount++;
	    const playCheck = playCount;
	    lightOn(primaryContainer);
	    lightOn(secondaryContainer);
	    setTimeout(() => {
		if(playCheck === playCount){
		    lightsOff();
		}
	    }, roundDuration * 1000);
	}

	function followUp () {
	    round = "sharporflat";
	    instructions.innerHTML = "Question: Is the second note sharp or flat?";
	    console.log(`Round = ${round} Sign = ${sign}`);
	    buttonOne.innerHTML = "Sharp";
	    buttonTwo.innerHTML = "Flat";

	    playAudioBuffer(primaryBuffer, 0, panLeft, followUpDuration);
	    playCount++;
	    const playCheck = playCount;
  	    lightsOff();
	    lightOn(primaryContainer);
	    setTimeout(() => {
		if(playCount === playCheck) {
		    lightsOff();
		    lightOn(secondaryContainer);
		    playAudioBuffer(secondaryBuffer, detuneAmount, panRight, followUpDuration);
		    setTimeout(() => {
			if(playCount === playCheck) {
			    lightsOff();
			}
		    }, followUpDuration * 1000);
		}	
	    }, followUpDuration * 1000);
	}

	function lightOn(container) {
	    container.style.backgroundColor = "#090";
	}

	function lightsOff() {
	    primaryContainer.style.backgroundColor = "#333";
	    secondaryContainer.style.backgroundColor = "#333";
	}

// ||-----------------------------Game Controls UI-----------------------------------||

	const optionsButton = document.getElementById("optionsButton");
	const backButton = document.getElementById("backButton");

	function showScreen(screenId) {
	    const screens = ["welcomeScreen", "gameControls", "menuScreen", "resultsScreen"]
	    screens.forEach((id) => {
		document.getElementById(id).classList.add("hidden");
	    });
	    document.getElementById(screenId).classList.remove("hidden");
	}

	optionsButton.addEventListener('click', () => {
	    stopAllAudio();
	    showScreen("menuScreen");
	    isPaused = true;
	    
	});
	backButton.addEventListener('click', () => {
	    showScreen("gameControls");
	    isPaused = false;
	    if (requireNextRound) {
		if (gamemode === "freeplay") {
		    timer = 0;
		    updateTimerDisplay();
		} else if (gamemode === "timermode") {
		    timer = 180;
		    updateTimerDisplay();
		}
		score = 0;
		updateScore();
		requireNextRound = false;
		nextRound();
	    }
	});

	// Starts the game when user clicks start
	gameStart.addEventListener('click', () => {
	    showScreen("gameControls")
	    gameStarted = true;
	    startTimer();
	    nextRound();
	});
	let wasIncorrect = false;
	function updateScore() {
	    scoreText.innerHTML = `${score}`;
	}
	buttonOne.addEventListener('click', () => {
	// Button One says "In Tune" or "Sharp"
	    stopAllAudio();
	    if ((round === "inorout") && (inTune)) {
		// Correct!
		textContent.innerHTML = `Correct! They are in tune.`;
		score++;
		increaseDifficulty++;
		if (increaseDifficulty === 2) {
		    difficulty = difficulty * .8;
		    increaseDifficulty = 0;
		}
		updateScore();
		nextRound();
	    }
	    else if ((round === "inorout") && (!inTune)) {
		// Incorrect!
		wasIncorrect = true;
		textContent.innerHTML = `Incorrect. They are out of tune.`;
		increaseDifficulty = 0;
		followUp();
	    }
	    else if ((round === "sharporflat") && (sign === 1)) {
		textContent.innerHTML = `Correct! Sharp by ${detuneAmount.toFixed(1)} cents`;
		score++;
		if (!wasIncorrect) {
		    difficulty = difficulty * .8;
		}
		wasIncorrect = false;
		updateScore();
		nextRound();
	    }
	    else if ((round === "sharporflat") && (sign === -1)) {
		// Incorrect!
		textContent.innerHTML = `Incorrect. Flat by ${Math.abs(detuneAmount).toFixed(1)} cents`;
		difficulty = difficulty / .8;
		wasIncorrect = false; // Reset for next round.
		nextRound();
	    }
	});

	buttonTwo.addEventListener('click', () => {
	// Button Two says "Out of Tune" or "Flat"
	    stopAllAudio();
	    if ((round === "inorout") && (inTune)) {
		// Incorrect!
		textContent.innerHTML = `Incorrect. They are in tune.`;
		increaseDifficulty = 0;
		nextRound();
	    }
	    else if ((round === "inorout") && (!inTune)) {
		// Correct!
		textContent.innerHTML = `Correct! They are out of tune.`;
		score++;
		updateScore();
		followUp();
	    }
	    else if ((round === "sharporflat") && (sign === 1)) {
		// Incorrect!
		textContent.innerHTML = `Incorrect. Sharp by ${detuneAmount.toFixed(1)} cents`;
		difficulty = difficulty / .8;
		wasIncorrect = false; // Reset for next round.
		nextRound();
	    }
	    else if ((round === "sharporflat") && (sign === -1)) {
		// Correct!
		textContent.innerHTML = `Correct. Flat by ${Math.abs(detuneAmount).toFixed(1)} cents`;
		score++;
		updateScore();
		if (!wasIncorrect) {
		    difficulty = difficulty * .8;
		}
		wasIncorrect = false;
		nextRound();
	    }
	});

	// Allows user to replay the audio.
	repeatButton.addEventListener('click', () => {
	    stopAllAudio();
	    if (round === "inorout") {
		playAudioBuffer(primaryBuffer);
	    	playAudioBuffer(secondaryBuffer, detuneAmount);
	    	playCount++;
	    	const playCheck = playCount;
	    	lightOn(primaryContainer);
	    	lightOn(secondaryContainer);
	    	setTimeout(() => {
		    if(playCheck === playCount){
		    	lightsOff();
		    }
	    	}, roundDuration * 1000);
	    } else {
	    	playAudioBuffer(primaryBuffer, 0, panLeft, followUpDuration);
	    	playCount++;
	    	const playCheck = playCount;
  	    	lightsOff();
	    	lightOn(primaryContainer);
	    	setTimeout(() => {
		    if(playCount === playCheck) {
		    	lightsOff();
		    	lightOn(secondaryContainer);
		    	playAudioBuffer(secondaryBuffer, detuneAmount, panRight, followUpDuration);
		    	setTimeout(() => {
			    if(playCount === playCheck) {
			    	lightsOff();
			    }
		    	}, followUpDuration * 1000);
		    }	
	    	}, followUpDuration * 1000);
	    }
	});
	
    </script>

    <script>
	// Call startTimer();

	const timerDisplay = document.getElementById("timerDisplay");
	const pauseButton = document.getElementById("pauseButton");

	let timer = 0;
	let timerInterval = null;
	let isPaused = false;

	function updateTimerDisplay() {
	    const minutes = String(Math.floor(timer / 60)).padStart(2, '0');
	    const seconds = String(timer % 60).padStart(2, '0');
	    timerDisplay.textContent = `${minutes}:${seconds}`;
	}

	function startTimer() {
	    if (timerInterval) return; // Prevent multiple intervals
	    timerInterval = setInterval(() => {
	        if (!isPaused && gamemode === "freeplay") {
	            timer++;
	            updateTimerDisplay();
	        } else if (!isPaused && (gamemode === "timermode")) {
		    timer--;
		    updateTimerDisplay();
		}
	    }, 1000);
	}

	pauseButton.addEventListener('click', () => {
	    isPaused = !isPaused;
	    pauseButton.textContent = isPaused ? "Resume" : "Pause";
	});
    </script>

</body>
</html>