<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Gamemode v.4</title>

    <!-- Working document CSS instead of linking separate .css stylesheet -->
    <style>
	.hidden {
	    display: none;
	}
	.overlay-text {
	    color: white;
	}
    </style>
    <!-- Working document datacopy.js instead of linking separate .js file -->
    <script>
	const instruments = {
  	    "piccolo": {
    		octave: 2,
    		group: ["woodwind", "high"],
    		pitches: [
      		    "F5", "F6", "F7"]},
  	    "flute": {
    		octave: 1,
    		group: ["woodwind", "high"],
    		pitches: [
      		    "F4", "F5", "F6"]},
  	    "oboe": {
    		octave: 1,
    		group: ["woodwind", "high"],
    		pitches: [
      		    "F4", "F5", ]},
  	    "bassoon": {
    		octave: -1,
    		group: ["woodwind", "low"],
    		pitches: [
      		    "F2", "F3", "F4"]},
  	    "clarinet": {
    		octave: 0,
    		group: ["woodwind", "high"],
    		pitches: [
      		    "F3", "F4", "F5", ]},
  	    "bass-clarinet": {
    		octave: -1,
    		group: ["woodwind", "low"],
    		pitches: [
      		    "F2", "F3", "F4"]},
  	    "alto-sax": {
    		octave: 0,
    		group: ["woodwind", "high"],
    		pitches: [
      		    "F3", "F4", "F5", ]},
  	    "tenor-sax": {
    		octave: 0,
    		group: ["woodwind", "low"],
    		pitches: [
      		    "F3", "F4", ]},
  	    "bari-sax": {
    		octave: -1,
    		group: ["woodwind", "low"],
    		pitches: [
      		    "F2", "F3", "F4", ]},
  	    "trumpet": {
    		octave: 0,
    		group: ["brass", "high"],
    		pitches: [
      		    "F3", "F4", "F5", ]},
  	    "french-horn": {
    		octave: 0,
    		group: ["brass", "high"],
    		pitches: [
      		    "F2", "F3", "F4", "F5"]},
  	    "trombone": {
    		octave: -1,
    		group: ["brass", "low"],
    		pitches: [
      		    "F2", "F3", "F4", ]},
  	    "baritone": {
    		octave: -1,
    		group: ["brass", "low"],
    		pitches: [
      		    "F2", "F3", "F4", ]},
  	    "tuba": {
    		octave: -2,
    		group: ["brass", "low"],
    		pitches: [
      		    "F1", "F2", "F3", ]},
	};
    </script>


</head>

<body>
    <h1 class="center">Intonation Trainer</h1>
    
    <div class="ui-container center vert-center">

<!-- ||------------------------Welcome Screen UI--------------------------|| -->

	<div id="welcomeScreen" class="vert-center">
	    <button id="gameStart" class="">Start Game</button>
	    <button id="startOptionsButton">Options</button>
	</div>

<!-- ||------------------------Game Controls UI---------------------------|| -->

	<div id="gameControls" class="game-controls hidden">
	    <div class="game-instructions">
		<div id="instructions">Question: Are the notes in tune or out of tune?</div>
	    </div>
	    <div class="waveform-wrapper">
	    	<div id="primaryContainer" class="waveform-container">
		    <div class="overlay-text">
		    	<div id="primaryInstrumentName">Clarinet</div>
		    	<div id="primaryInstrumentNote">F4</div>
		    </div>
	    	</div>
	        <div id="secondaryContainer" class="waveform-container">
		    <div class="overlay-text">
		    	<div id="secondaryInstrumentName">Trumpet</div>
		    	<div id="secondaryInstrumentNote">F4</div>
		    </div>
	    	</div>
	    </div>
	    <div id="2-buttons">
		<button class="game-button " id="in-sharp">In Tune</button>
		<button class="game-button " id="out-flat">Out of Tune</button>
	    </div>
	    <div id="1-button">
		<button id="repeat-button" class="">Replay Audio</button>
	    </div>
	    <div class="text-display">
		<span id="textContent">Feedback</span>
	    </div>
	    <br>
	    <div class="score-area">
		<div>Gamemode: <span id="gamemodeText"></span></div>
		<label>Score: </label><span id="score">0</span>
	    </div>
	    <div class="timer-area">
		<span id="timerDisplay" class="">00:00</span>
		<span id="livesText" class="hidden">Lives:
		    <span id="livesLeft">3</span> 
	        </span>
		<button id="pauseButton" class="">Finish</button>
		<button id="optionsButton">Options</button>
	    </div>
	</div>

<!-- ||-----------------------Menu Screen UI----------------------------|| -->

	<div id="menuScreen" class="hidden">
	    <div>
		<span>Difficulty</span>
		<button id="easyButton">Easy</button>
		<button id="mediumButton">Medium</button>
		<button id="hardButton">Hard</button>
	    </div>
	    <div>
		<span>Game Mode</span>
		<button id="freeplayButton">Free Play</button>
		<button id="timermodeButton">Timer</button>
		<button id="challengeButton">Challenge</button>
	    </div>
	    <div>
		<span>Intervals</span>
		<button id="unisonButton">Unison</button>
		<button id="octaveButton">Octave</button>
		<button id="autoInterval">Auto</button>
	    </div>
	    <div>
		<span>Select Instrument:</span>
		<select id="selectInstrumentDropdown">
		    <option value="all">All</option>
		    <option value="brass">Brass Only</option>
		    <option value="woodwind">Woodwinds</option>
		    <option value="high">High Voices</option>
		    <option value="low">Low Voices</option>
		</select>
	    </div>
	    <div>
		<button id="backButton">Back</button>
	    </div>
	</div>

<!-- ||----------------------------Results Screen UI--------------------------|| -->

	<div id="resultsScreen" class="hidden">
	    <div>
		<div><span id="motivationalText">You did a great job!</span></div>
		<br>
		<div>Correct Answers: <span id="correctTotalText">0</span></div>
		<div>In or Out of tune: <span id="correctTunedText">0</span></div>
		<div>Sharp: <span id="correctSharpText">0</span> Flat: <span id="correctFlatText">0</span></div>
		<br>
		<div>Incorrect Answers: <span id="incorrectTotalText">0</span></div>
		<div>In or Out of tune: <span id="incorrectTunedText">0</span></div>
		<div>Sharp: <span id="incorrectSharpText">0</span> Flat: <span id="incorrectFlatText">0</span></div>
		<br>
		<div>Game Mode: <span id="gamemodeResultsText">Free Play</span></div>
		<div>Hardest Difficulty: <span id="hardestDifficultyText">35</span> cents</div>
	    </div>
	    <br>
	    <button id="restartButton">Restart</button>
	    <button id="resultsOptionsButton">Options</button>
	</div>
    </div>

    <script>

// ||-------------------------- Results Screen Functions -------------------------||

	const resultsOptionsButton = document.getElementById("resultsOptionsButton");
	resultsOptionsButton.addEventListener('click', () => {
	    backButton.innerHTML = "New Round";
	    requireNextRound = true;
	    showScreen("menuScreen");
	    isPaused = true;
	});

	const restartButton = document.getElementById("restartButton");
	restartButton.addEventListener('click', () => {
	    if (gamemode === "timermode") {
	        timer = timerAmount;
	    } else {
		timer = 0;
	    }
	    if (gamemode !== "challenge") {
	        clearInterval(timerInterval);
		timerInterval = null;
		console.log(`timerintervalPre=${timerInterval} ispaused=${isPaused}`);
		isPaused = false;
		updateTimerDisplay();
	        startTimer();
	    }
	    console.log(`gamemode=${gamemode} timer=${timer} timerinterval=${timerInterval} ispaused=${isPaused}`)
	    showScreen(screens[1]);
	    resetStats();
	    score = 0;
	    updateScore();
	    stopFollowUp = false;
	    nextRound();
	});
	let correctSharp = 0;
	let correctFlat = 0;
	let correctTuned = 0;
	let incorrectSharp = 0; // answered flat when note was sharp
	let incorrectFlat = 0; // answered sharp when note was flat
	let incorrectTuned = 0; // answered out of tune when notes were in tune
	let hardestDifficulty = 35;
	function resetStats() {
	    difficulty = rememberDifficulty;
	    correctSharp = 0;
	    correctFlat = 0;
	    correctTuned = 0;
	    incorrectSharp = 0;
	    incorrectFlat = 0;
	    incorrectTuned = 0;
	}
	const correctTunedText = document.getElementById("correctTunedText");
	const correctSharpText = document.getElementById("correctSharpText");
	const correctFlatText = document.getElementById("correctFlatText");
	const incorrectTunedText = document.getElementById("incorrectTunedText");
	const incorrectSharpText = document.getElementById("incorrectSharpText");
	const incorrectFlatText = document.getElementById("incorrectFlatText");
	const hardestDifficultyText = document.getElementById("hardestDifficultyText");
	const correctTotalText = document.getElementById("correctTotalText");
	const incorrectTotalText = document.getElementById("incorrectTotalText");
	const gamemodeResultsText = document.getElementById("gamemodeResultsText");
	const motivationalText = document.getElementById("motivationalText");
	const motivationalQuotes = ["You're doing great!", "Nice tuning skills!", "Pitch perfect!", "Keep it in tune!", "Sounding awesome!", "Sharp work!", "Right on pitch!", "Stay in tune!", "Your ears rock!", "Tuning mastery!"];
	let quote = 0;
	function updateStats() {
	    motivationalText.innerHTML = motivationalQuotes[quote];
	    quote = (quote + 1) % motivationalQuotes.length;
	    correctTotalText.innerHTML = correctTuned + correctSharp + correctFlat;
	    correctTunedText.innerHTML = correctTuned;
	    correctSharpText.innerHTML = correctSharp;
	    correctFlatText.innerHTML = correctFlat;
	    incorrectTotalText.innerHTML = incorrectTuned + incorrectSharp + incorrectFlat;
	    incorrectTunedText.innerHTML = incorrectTuned;
	    incorrectSharpText.innerHTML = incorrectSharp;
	    incorrectFlatText.innerHTML = incorrectFlat;
	    hardestDifficultyText.innerHTML = hardestDifficulty.toFixed(1);
	    if (gamemode === "freeplay") {
		gamemodeResultsText.innerHTML = "Free Play";
	    } else if (gamemode === "timermode") {
		gamemodeResultsText.innerHTML = "Timer";
	    } else {
		gamemodeResultsText.innerHTML = "Challenge";
	    }
	}

// ||-----------------------------Start Screen UI-----------------------------------||

	const startOptionsButton = document.getElementById("startOptionsButton");
	startOptionsButton.addEventListener('click', () => {
	    backButton.innerHTML = "New Round";
	    requireNextRound = true;
	    showScreen("menuScreen");
	});

	const gameStart = document.getElementById("gameStart");
	gameStart.addEventListener('click', () => {
	    showScreen("gameControls")
	    isPaused = false;
	    stopFollowUp = false;
	    startTimer();
	    nextRound();
	});

// ||-----------------------------Game Controls UI-----------------------------------||

	const screens = ["welcomeScreen", "gameControls", "menuScreen", "resultsScreen"]
	function showScreen(screenId) {
	    screens.forEach((id) => {
		document.getElementById(id).classList.add("hidden");
	    });
	    document.getElementById(screenId).classList.remove("hidden");
	}

	const optionsButton = document.getElementById("optionsButton");
	optionsButton.addEventListener('click', () => {
	    stopAllAudio();
	    stopFollowUp = true;
	    showScreen("menuScreen");
	    isPaused = true;    
	});

	const pauseButton = document.getElementById("pauseButton");
	pauseButton.addEventListener("click", () => {
	    if (gamemode === "freeplay") {
		// Finishes the Free Play game
		stopAllAudio();
		stopFollowUp = true;
		updateStats();
		showScreen("resultsScreen");
		isPaused = true;
		clearInterval(timerInterval);
		timerInterval = null;
	    } else if (gamemode === "timermode") {
		// Restarts Timer Mode game
		console.log(`pre timer=${timer} timerinterval=${timerInterval} ispaused=${isPaused}`);
		stopAllAudio();
		stopFollowUp = true;
		score = 0;
		updateScore();
		resetStats();
		timer = timerAmount;
		updateTimerDisplay();
		clearInterval(timerInterval);
		timerInterval = null;
		isPaused = false;
		startTimer();
		console.log(`post timer=${timer} timerinterval=${timerInterval} ispaused=${isPaused}`);
		nextRound();
	    } else {
		// Restarts Challenge Mode game
		stopAllAudio();
		stopFollowUp = true;
		score = 0;
		updateScore();
		resetStats();
		lives = 3;
		livesLeft.innerHTML = lives;
		nextRound();
	    }
	});

	let stopFollowUp = false;
	const diffChange = .8;
	let wasIncorrect = false;
	function updateScore() {
	    scoreText.innerHTML = `${score}`;
	}

	const buttonOne = document.getElementById("in-sharp");
	buttonOne.addEventListener('click', () => {
	// Button One says "In Tune" or "Sharp"
	    stopAllAudio();
	    if ((round === "inorout") && (inTune)) {
		// Correct!
		textContent.innerHTML = `Correct! They are in tune.`;
		score++;
		correctTuned++;
		increaseDifficulty++;
		if (increaseDifficulty === 2) {
		    difficulty = difficulty * diffChange;
		    increaseDifficulty = 0;
		}
		updateScore();
		nextRound();
	    }
	    else if ((round === "inorout") && (!inTune)) {
		// Incorrect!
		wasIncorrect = true;
		textContent.innerHTML = `Incorrect. They are out of tune.`;
		incorrectTuned++;
		if ((gamemode === "challenge") && (lives === 1)) {
	    	    stopAllAudio();
		    stopFollowUp = true;
		    lives--;
		    livesLeft.innerHTML = lives;
		    updateStats();
		    setTimeout(() => showScreen("resultsScreen"), 2000);
	    	    return;
		} else if ((gamemode === "challenge") && (lives > 1)) {
		    lives--;
		    livesLeft.innerHTML = lives;
		}
		increaseDifficulty = 0;
		difficulty = difficulty / diffChange;
		followUp();
	    }
	    else if ((round === "sharporflat") && (sign === 1)) {
		// Correct!
		textContent.innerHTML = `Correct! Sharp by ${detuneAmount.toFixed(1)} cents`;
		score++;
		correctSharp++;
		if (!wasIncorrect) {
		    difficulty = difficulty * diffChange;
		}
		wasIncorrect = false;
		updateScore();
		nextRound();
	    }
	    else if ((round === "sharporflat") && (sign === -1)) {
		// Incorrect!
		textContent.innerHTML = `Incorrect. Flat by ${Math.abs(detuneAmount).toFixed(1)} cents`;
		incorrectFlat++;
		difficulty = difficulty / diffChange;
		wasIncorrect = false; // Reset for next round.
		if ((gamemode === "challenge") && (lives === 1)) {
	    	    stopAllAudio();
		    stopFollowUp = true;
		    lives--;
		    livesLeft.innerHTML = lives;
		    updateStats();
		    setTimeout(() => showScreen("resultsScreen"), 2000);
	    	    return;
		} else if ((gamemode === "challenge") && (lives > 1)) {
		    lives--;
		    livesLeft.innerHTML = lives;
		}
		nextRound();
	    }
	});

	const buttonTwo = document.getElementById("out-flat");
	buttonTwo.addEventListener('click', () => {
	// Button Two says "Out of Tune" or "Flat"
	    stopAllAudio();
	    if ((round === "inorout") && (inTune)) {
		// Incorrect!
		textContent.innerHTML = `Incorrect. They are in tune.`;
		incorrectTuned++;
		increaseDifficulty = 0;
		if ((gamemode === "challenge") && (lives === 1)) {
	    	    stopAllAudio();
		    stopFollowUp = true;
		    lives--;
		    livesLeft.innerHTML = lives;
		    updateStats();
		    setTimeout(() => showScreen("resultsScreen"), 2000);
	    	    return;
		} else if ((gamemode === "challenge") && (lives > 1)) {
		    lives--;
		    livesLeft.innerHTML = lives;
		}
		nextRound();
	    }
	    else if ((round === "inorout") && (!inTune)) {
		// Correct!
		textContent.innerHTML = `Correct! They are out of tune.`;
		score++;
		correctTuned++;
		updateScore();
		followUp();
	    }
	    else if ((round === "sharporflat") && (sign === 1)) {
		// Incorrect!
		textContent.innerHTML = `Incorrect. Sharp by ${detuneAmount.toFixed(1)} cents`;
		incorrectSharp++;
		difficulty = difficulty / diffChange;
		wasIncorrect = false; // Reset for next round.
		if ((gamemode === "challenge") && (lives === 1)) {
	    	    stopAllAudio();
		    stopFollowUp = true;
		    lives--;
		    livesLeft.innerHTML = lives;
		    updateStats();
		    setTimeout(() => showScreen("resultsScreen"), 2000);
	    	    return;
		} else if ((gamemode === "challenge") && (lives > 1)) {
		    lives--;
		    livesLeft.innerHTML = lives;
		}
		nextRound();
	    }
	    else if ((round === "sharporflat") && (sign === -1)) {
		// Correct!
		textContent.innerHTML = `Correct. Flat by ${Math.abs(detuneAmount).toFixed(1)} cents`;
		score++;
		correctFlat++;
		updateScore();
		if (!wasIncorrect) {
		    difficulty = difficulty * diffChange;
		}
		wasIncorrect = false;
		nextRound();
	    }
	});

	// Allows user to replay the audio.
	const repeatButton = document.getElementById("repeat-button");
	repeatButton.addEventListener('click', () => {
	    stopAllAudio();
	    if (round === "inorout") {
		playAudioBuffer(primaryBuffer);
	    	playAudioBuffer(secondaryBuffer, detuneAmount);
	    	playCount++;
	    	const playCheck = playCount;
	    	lightOn(primaryContainer);
	    	lightOn(secondaryContainer);
	    	setTimeout(() => {
		    if(playCheck === playCount){
		    	lightsOff();
		    }
	    	}, roundDuration * 1000);
	    } else {
	    	playAudioBuffer(primaryBuffer, 0, panLeft, followUpDuration);
	    	playCount++;
	    	const playCheck = playCount;
  	    	lightsOff();
	    	lightOn(primaryContainer);
		if (stopFollowUp) return;
	    	setTimeout(() => {
		    if(playCount === playCheck) {
			if (stopFollowUp) return;
		    	lightsOff();
		    	lightOn(secondaryContainer);
		    	playAudioBuffer(secondaryBuffer, detuneAmount, panRight, followUpDuration);
		    	setTimeout(() => {
			    if(playCount === playCheck) {
			    	lightsOff();
			    }
		    	}, followUpDuration * 1000);
		    }	
	    	}, followUpDuration * 1000);
	    }
	});
	
	// Call startTimer();
	const livesLeft = document.getElementById("livesLeft");
	const timerDisplay = document.getElementById("timerDisplay");

	let timer = 0;
	let timerInterval = null;
	let isPaused = false;

// ||---------------------------- Menu Screen Functions --------------------------||

	const backButton = document.getElementById("backButton");
	backButton.addEventListener('click', () => {
	    showScreen("gameControls");
	    isPaused = false;
	    stopFollowUp = false;
	    if (requireNextRound) {
		score = 0;
		updateScore();
		requireNextRound = false;
		nextRound();
		backButton.innerHTML = "Back";
	    }
	});

	// --- Select Instrument ---

	const selectInstrumentDropdown = document.getElementById("selectInstrumentDropdown");
	const instrumentKeys = Object.keys(instruments);
	let activeInstrumentList = instrumentKeys;
	let requireNextRound = false;

	function populateInstrumentDropdown() {
	    for (let i = 0; i < instrumentKeys.length; i++) {
		const newOption = document.createElement("option");
		const newInstrName = instrumentKeys[i];
		newOption.innerHTML = displayName(newInstrName);
		newOption.value = newInstrName;
		selectInstrumentDropdown.appendChild(newOption);
	    }
	}

	document.addEventListener("DOMContentLoaded", populateInstrumentDropdown);
	selectInstrumentDropdown.addEventListener('input', () => {
	    console.log(`${selectInstrumentDropdown.value}`);
	    if (selectInstrumentDropdown.value === "all") {
		activeInstrumentList = instrumentKeys;
	    } else if (selectInstrumentDropdown.value === "brass") {
		activeInstrumentList = Object.entries(instruments)
		    .filter(([name, data]) => data.group.includes("brass"))
		    .map(([name, _]) => name);
	    } else if (selectInstrumentDropdown.value === "woodwind") {
		activeInstrumentList = Object.entries(instruments)
		    .filter(([name, data]) => data.group.includes("woodwind"))
		    .map(([name, _]) => name);
	    } else if (selectInstrumentDropdown.value === "high") {
		activeInstrumentList = Object.entries(instruments)
		    .filter(([name, data]) => data.group.includes("high"))
		    .map(([name, _]) => name);
	    } else if (selectInstrumentDropdown.value === "low") {
		activeInstrumentList = Object.entries(instruments)
		    .filter(([name, data]) => data.group.includes("low"))
		    .map(([name, _]) => name);
	    } else {
	        activeInstrumentList = [selectInstrumentDropdown.value];
	    }
	    console.log(activeInstrumentList);
	    requireNextRound = true;
	    backButton.innerHTML = "New Round";
	});

	// --- Select Difficulty ---

	const easyButton = document.getElementById("easyButton");
	const mediumButton = document.getElementById("mediumButton");
	const hardButton = document.getElementById("hardButton");
	const difficulties = [35, 25, 15];
	let difficulty = difficulties[1];
	let rememberDifficulty = difficulties[1];
	
	easyButton.addEventListener('click', () => {
	    difficulty = difficulties[0];
	    rememberDifficulty = difficulties[0];
	    requireNextRound = true;
	    backButton.innerHTML = "New Round";
	});
	mediumButton.addEventListener('click', () => {
	    difficulty = difficulties[1];
	    rememberDifficulty = difficulties[1];
	    requireNextRound = true;
	    backButton.innerHTML = "New Round";
	});
	hardButton.addEventListener('click', () => {
	    difficulty = difficulties[2];
	    rememberDifficulty = difficulties[2];
	    requireNextRound = true;
	    backButton.innerHTML = "New Round";
	});

	// --- Select Game Mode ---

	let gamemode = "freeplay";
	
	const gamemodeText = document.getElementById("gamemodeText");
	gamemodeText.innerHTML = "Free Play";
	const freeplayButton = document.getElementById("freeplayButton");
	const timermodeButton = document.getElementById("timermodeButton");
	const challengeButton = document.getElementById("challengeButton");

	function showDisplay(displayId) {
	    const displays = ["timerDisplay", "livesText"];
	    displays.forEach((id) => {
		document.getElementById(id).classList.add("hidden");
	    });
	    document.getElementById(displayId).classList.remove("hidden");
	}
	freeplayButton.addEventListener('click', () => {
	    if (gamemode !== "freeplay") {
	    	gamemode = "freeplay";
		gamemodeText.innerHTML = "Free Play";
		pauseButton.innerHTML = "Finish";
		showDisplay("timerDisplay");
		timer = 0;
		updateTimerDisplay();
		clearInterval(timerInterval);
		timerInterval = null;
		startTimer();
	    	requireNextRound = true;
	    	backButton.innerHTML = "New Round";
	    }
	});
	timermodeButton.addEventListener('click', () => {
	    if (gamemode !== "timermode") {
		gamemode = "timermode";
		gamemodeText.innerHTML = "Timer";
		pauseButton.innerHTML = "Restart";
		showDisplay("timerDisplay");
		timer = timerAmount;
		updateTimerDisplay();
		clearInterval(timerInterval);
		timerInterval = null;
		startTimer();
		console.log(`gamemode=${gamemode}, timer=${timer}`);
		requireNextRound = true;
	    	backButton.innerHTML = "New Round";
	    }
	});
	let timerAmount = 60; // Used for Timer Gamemode
	challengeButton.addEventListener('click', () => {
	    if (gamemode !== "challenge") {
		gamemode = "challenge";
		lives = 3;
		gamemodeText.innerHTML = "Challenge";
		pauseButton.innerHTML = "Restart";
		showDisplay("livesText");
		clearInterval(timerInterval);
		timerInterval = null;
		requireNextRound = true;
	    	backButton.innerHTML = "New Round";
	    }
	});
	let lives = 3; // 3 for testing, change to 5 later?
// The Pause button should maybe read "Finish" to bring the user to the results screen. Results screen can include information like "hardest difficulty reached", "percentage of correct answers", and maybe at some point use cookies to remember "high score" between sessions.

// Results screen ideas: positive reinforcement statements! How many missed sharp versus flat, how many missed high versus low. Display settings, hardest difficulty reached, 


// I'm also thinking about using the START UI screen in this way: using cookies, the last settings are remembered (difficulty, gamemode, intervals, instrument selection) so that pushing "start" will automatically start the game with the last selected settings. Then, on the GAME CONTROLS UI, the "options" button will allow the user to pause and possibly reset their game with different settings. Just pushing "options" and not changing anything will effectively pause the game, allowing the user to push "back" without resetting anything, but changing any of the settings will trigger a "requireRestart" bool and "back" will reset the game with the new settings.


// ----------- Select Intervals ---------
	
	const intervals = ["unison", "octave", "auto"]
	let interval = intervals[0];

	const unisonButton = document.getElementById("unisonButton");
	unisonButton.addEventListener('click', () => {
	    if (interval !== intervals[0]) {
		requireNextRound = true;
	    	interval = intervals[0];
	    }
	    console.log(`interval = ${interval}`);
	});
	const octaveButton = document.getElementById("octaveButton");
	octaveButton.addEventListener('click', () => {
	    if (interval !== intervals[1]) {
		requireNextRound = true;
	    	interval = intervals[1];
	    }
	    console.log(`interval = ${interval}`);
	});
	const autoInterval = document.getElementById("autoInterval");
	autoInterval.addEventListener('click', () => {
	    if (interval !== intervals[2]) {
		requireNextRound = true;
	    	interval = intervals[2];
	    }
	    console.log(`interval = ${interval}`);
	});
	
// ||------------------------------- Global Script Variables ----------------------------------||

	const audioContext = new (window.AudioContext);
	const textContent = document.getElementById("textContent");
	const gameControls = document.getElementById("gameControls");
	const scoreText = document.getElementById("score");
	const primaryContainer = document.getElementById("primaryContainer");
	const secondaryContainer = document.getElementById("secondaryContainer");
	const instructions = document.getElementById("instructions");

	let score = 0;
	let round = "inorout";
	let primary = null;
	let secondary = null;
	let primaryBuffer = null;
	let secondaryBuffer = null;
	let inTune = true;
	let detuneAmount = 0;
	let sign = 1;
	let roundDuration = 2.5;
	let followUpDuration = 2;
	let panLeft = -.8;
	let panRight = .8;
	let activeSources = [];
	let intervalType = null;
	let playCount = 0;
	let increaseDifficulty = 0;



// ||---------------------------------------Function Definitions-------------------------------||

    // ......Audio Playback Functions......

	async function loadAudioBuffer(filePath) {
  	    const response = await fetch(filePath);
  	    const arrayBuffer = await response.arrayBuffer();
  	    return await audioContext.decodeAudioData(arrayBuffer);
	}

	function playAudioBuffer(audioBuffer, detuneAmount = 0, panValue = 0, duration = roundDuration) {
  	    const source = audioContext.createBufferSource();
  	    source.buffer = audioBuffer;

  	    const gainNode = audioContext.createGain();
  	    const panner = audioContext.createStereoPanner();
  	    panner.pan.value = panValue;

  	    const detuneRatio = Math.pow(2, detuneAmount / 1200);
  	    source.playbackRate.value = detuneRatio;

  	    source.connect(panner).connect(gainNode).connect(audioContext.destination);

  	    const now = audioContext.currentTime;
  	    gainNode.gain.setValueAtTime(1, now);
  	    gainNode.gain.setValueAtTime(1, now + duration);
  	    gainNode.gain.linearRampToValueAtTime(0, now + duration + .5);

  	    source.start(now);
  	    source.stop(now + duration)

  	    activeSources.push(source); // Tracks array of audio sources for stopAllAudio().
	}

	function stopAllAudio() {
	    lightsOff();
  	    activeSources.forEach(source => {
    		try {
      		    source.stop();
    		} catch (e) {
    		}
  	    });
  	    activeSources = [];  // Requires global variable let activeSources = [];
	}

    // ......Randomizing and Round Functions......

    	function randomInstrument() {
	    const name = activeInstrumentList[Math.floor(Math.random() * activeInstrumentList.length)];
	    const instrument = instruments[name];
	    return { instrument, name };
	}

    	function generateRandom() {
     	    // Returns an object to be used as file path for loadAudioBuffer(filePath);
	    const { instrument, name } = randomInstrument();
	    const pitch = instrument.pitches[Math.floor(Math.random() * instrument.pitches.length)];
	    return {
	  	filePath: `tempaudio/${name}/${pitch}.mp3`,
	  	name: name,
	  	pitch: pitch,
	    };
    	}

	function displayName(name) {
      	    return name.replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
	}

	function parseNote(input) {
  	    const note = input.slice(0, -1); // assumes all notes have a 1-digit octave
  	    const octave = parseInt(input.slice(-1), 10);
  	    return { note, octave };
	}

	async function nextRound() {
	    stopFollowUp = false;
	    console.log(`difficulty = ${difficulty}, increase = ${increaseDifficulty}`);
	    round = "inorout";
	    instructions.innerHTML = "Question: Are the notes in tune or out of tune?";
	    buttonOne.innerHTML = "In Tune";
	    buttonTwo.innerHTML = "Out of Tune";
	    inTune = Math.random() < 0.5 ? true : false;
	    console.log(`Round = ${round}, inTune = ${inTune}`);
	    if (difficulty < hardestDifficulty) hardestDifficulty = difficulty;
	    if (inTune) {
		detuneAmount = 0;
	    } else {
		sign = Math.random() < 0.5 ? 1 : -1;
		detuneAmount = (sign * difficulty);
	    }
	    primary = generateRandom();
	    primaryInstrumentName.innerHTML = displayName(primary.name);
	    primaryInstrumentNote.innerHTML = primary.pitch;
	    primaryBuffer = await loadAudioBuffer(primary.filePath);
	    let newNote = null;
	// Insert interval game option logic check here
	    intervalType = interval;
	    if (intervalType === intervals[2]) {
	    	intervalType = Math.random() < 0.5 ? "octave" : "unison";
	    }
	    console.log(`intervalType = ${intervalType}`);
	    if (intervalType === "octave") {
	    // Searches for a new note in Octaves...
		secondary = generateRandom();
		let primaryInstrument = instruments[primary.name];
		let secondaryInstrument = instruments[secondary.name];
		const parsedNote = parseNote(primary.pitch);

		if (primaryInstrument.octave === secondaryInstrument.octave) {
		// The instruments are pitched in the same octave...
		    const direction = Math.random() < .5 ? 1 : -1;
		    const distances = [1, -1, 2, -2, 3, -3, 4, -4, 5, -5, 6, -6];
		    for (let i = 0; i < distances.length; i++) {
			const testOctave = parsedNote.octave + (distances[i] * direction);
			const candidate = parsedNote.note + testOctave;
			if (secondaryInstrument.pitches.includes(candidate)) {
			    newNote = candidate;
			    break;
			}
		    }
		} else {
		// The instruments are pitched in different octaves already...
		    let normalizedOctave = secondaryInstrument.octave - primaryInstrument.octave;
		    let testOctave = parsedNote.octave + normalizedOctave;
		    let candidate = parsedNote.note + testOctave;
		    if (secondaryInstrument.pitches.includes(candidate)) {
			newNote = candidate;
		    } else {
          	    	const direction = Math.random() < .5 ? 1 : -1;
          	    	const distances = [1, -1, 2, -2, 3, -3, 4, -4];
          	    	for (let i = 0; i < distances.length; i++) {
	    		    testOctave = parsedNote.octave + (distances[i] * direction);
	    		    candidate = parsedNote.note + testOctave;
	    		    if (secondaryInstrument.pitches.includes(candidate)) {
	      		    	newNote = candidate;
	      		    	break;
          	    	    }
			}
		    }
		}
	    } else {
	    // Searches for a new note in Unison...
		secondary = generateRandom();
		newNote = primary.pitch;
		let pitches = [];
		let name = "";
		let instrument = null;
		while (!pitches.includes(primary.pitch)) {
		    name = activeInstrumentList[Math.floor(Math.random() * activeInstrumentList.length)];
		    instrument = instruments[name];
		    pitches = instrument.pitches;
		    secondary.name = name;
		}
	    }
	    secondaryInstrumentName.innerHTML = displayName(secondary.name);
	    secondaryInstrumentNote.innerHTML = newNote;	    
	    const filePath = `tempaudio/${secondary.name}/${newNote}.mp3`;
	    secondaryBuffer = await loadAudioBuffer(filePath);

	    playAudioBuffer(primaryBuffer);
	    // console.log(`${primary.filePath}`);
	    playAudioBuffer(secondaryBuffer, detuneAmount);
	    // console.log(`Secondary: ${secondary.name} ${newNote} ${detuneAmount}`);
	    playCount++;
	    const playCheck = playCount;
	    lightOn(primaryContainer);
	    lightOn(secondaryContainer);
	    setTimeout(() => {
		if(playCheck === playCount){
		    lightsOff();
		}
	    }, roundDuration * 1000);
	}

	function followUp () {
	    if (stopFollowUp) return;
	    round = "sharporflat";
	    instructions.innerHTML = "Question: Is the second note sharp or flat?";
	    console.log(`Round = ${round} Sign = ${sign}`);
	    buttonOne.innerHTML = "Sharp";
	    buttonTwo.innerHTML = "Flat";

	    playAudioBuffer(primaryBuffer, 0, panLeft, followUpDuration);
	    playCount++;
	    const playCheck = playCount;
  	    lightsOff();
	    lightOn(primaryContainer);
	    setTimeout(() => {
		if (stopFollowUp) return;
		if (playCount === playCheck) {
		    lightsOff();
		    lightOn(secondaryContainer);
		    playAudioBuffer(secondaryBuffer, detuneAmount, panRight, followUpDuration);
		    setTimeout(() => {
			if(playCount === playCheck) {
			    lightsOff();
			}
		    }, followUpDuration * 1000);
		}	
	    }, followUpDuration * 1000);
	}

	function lightOn(container) {
	    container.style.backgroundColor = "#090";
	}

	function lightsOff() {
	    primaryContainer.style.backgroundColor = "#333";
	    secondaryContainer.style.backgroundColor = "#333";
	}

	function updateTimerDisplay() {
	    const minutes = String(Math.floor(timer / 60)).padStart(2, '0');
	    const seconds = String(timer % 60).padStart(2, '0');
	    timerDisplay.textContent = `${minutes}:${seconds}`;
	}

	function startTimer() {
	    if (timerInterval) return; // Prevent multiple intervals
	    timerInterval = setInterval(() => {
	        if (!isPaused && gamemode === "freeplay") {
	            timer++;
	            updateTimerDisplay();
	        } else if (!isPaused && (gamemode === "timermode")) {
		    timer--;
		    updateTimerDisplay();
		    if (timer < 0) {
			stopAllAudio();
			isPaused = true;
			updateStats();
			showScreen("resultsScreen");
		    }
		}
	    }, 1000);
	}

    </script>

</body>
</html>